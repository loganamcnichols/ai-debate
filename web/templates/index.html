<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AI Debate</title>
  <link rel="stylesheet" href="static/css/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Libre+Franklin:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/htmx.org@2.0.2/dist/htmx.js" integrity="sha384-yZq+5izaUBKcRgFbxgkRYwpHhHHCpp5nseXp0MEQ1A4MTWVMnqkmcuFez8x5qfxr" crossorigin="anonymous"></script>
  <script src="static/js/sse.min.js"></script>
  <script src="https://unpkg.com/hyperscript.org@0.9.12" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.19.2/dist/ort.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.19/dist/bundle.min.js"></script>
</head>
<body _="on load wait 3s sendMessageToParent('chatlog-id', '{{ .ResponseID }}')"
      hx-ext="sse" sse-connect="/chat?response-id={{ .ResponseID }}" 
      sse-close="close" hx-on::sse-close="console.log('sse closed');">
  <data sse-swap="keep-alive" hx-swap="none"></data>
  <data id="ticker" hx-target="body" hx-get="/survey?response-id={{ .ResponseID }}&page=1" hx-trigger="every {{ .ChatTime }}m"></data>
  <div>
    Time until survey
    <div id="countdown-timer">
    </div>
  </div>
  <footer sse-swap="active-form" hx-swap="innerHTML" hx-target="this">
  {{ if gt (len .QuestionRows) 0 }}
  {{ block "active-form" .ResponseID }}
    <form id="suggestion-form" hx-post="/submit-suggestion?response-id={{ . }}" hx-trigger="submit"> 
      <button id="prompt-button" type="submit" hx-trigger="every 5s, load consume" 
              hx-get="prompt-suggestion?response-id={{ . }}" hx-target="this" hx-swap="innerHTML"></button>
    </form>
    <form id="submission-form" hx-post="/submit-question?response-id={{ . }}"
          hx-trigger="keydown[key==='Enter'&&!shiftKey], submit, opening" 
           _="on htmx:beforeRequest get #user-input then 
                if its value equals '' 
                  halt the event 
                end">
      <div class="textbar">
        <textarea name="user-msg" id="user-input" rows="1" value="Opening arguments"
        _="on keydown[key is 'Enter' and no shiftkey] halt the event's default 
           on input set my *height to my scrollHeight px"></textarea>
        <button id="input-button" type="submit">
          <img src="static/images/send.svg">
        </button>
      </div>
    </form>
    {{ end }}
    {{ else }}
    {{ block "inactive-form" .ResponseID }}
    <form id="submission-form" hx-post="/submit-suggestion?response-id={{ . }}" 
          hx-trigger="keydown[key==='Enter'&&!shiftKey], submit, opening" 
          hx-swap="beforeend" hx-target="main"
           _="on htmx:beforeRequest get #user-input then 
                if its value equals '' 
                  halt the event 
                end">
      <div class="textbar">
        <textarea name="user-msg" id="user-input" rows="1" value="Opening arguments" disabled
        _="on keydown[key is 'Enter' and no shiftkey] halt the event's default 
           on input set my *height to my scrollHeight px"></textarea>
        <button id="input-button" type="submit" disabled>
          <img src="static/images/send.svg">
        </button>
      </div>
    </form>
    {{ end }}
    {{ end }}
  </footer>
<script>
  // Insert the JavaScript code from the artifact here
  function startCountdown(duration) {
    let timer = duration;
    const countdownElement = document.getElementById('countdown-timer');

    const updateTimer = () => {
      const minutes = Math.floor(timer / 60);
      let seconds = timer % 60;

      seconds = seconds < 10 ? "0" + seconds : seconds;
      countdownElement.textContent = minutes + ":" + seconds;

      if (--timer < 0) {
        countdownElement.textContent = "Time's up!";
        clearInterval(interval);
      }
    };

    updateTimer();
    const interval = setInterval(updateTimer, 1000);
  }

  // Start the countdown when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    const chatTime = parseInt("{{ .ChatTime }}"); // Get the ChatTime value
    startCountdown(60 * chatTime);
  });

  // Helper function to convert ArrayBuffer to base64
  function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;

    // Handle large buffers by processing in chunks
    const chunkSize = 0x8000; // 32KB
    for (let i = 0; i < len; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }

    return window.btoa(binary);
  }

  function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }

  const SPEECH_STARTED = 1;
  const SPEECH_ENDED = 0;

  async function setupAudioStream() {
    try {
      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error("getUserMedia not supported");
      }

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioCtx = new AudioContext();
      const socket = new WebSocket(`ws://localhost:8080/ws?sample-rate=${audioCtx.sampleRate}`);
      socket.binaryType = "arraybuffer";
      
      // Wait for WebSocket connection
      await new Promise((resolve, reject) => {
        socket.onopen = resolve;
        socket.onerror = reject;
        socket.onclose = (event) => {
          console.error('WebSocket closed unexpectedly:', event.code, event.reason);
          // Attempt to reconnect or handle closure
        };
      });

      const inputNode = audioCtx.createMediaStreamSource(stream);
      let responseMS = 0;

      await audioCtx.resume();
      
      // Load audio worklets
      await audioCtx.audioWorklet.addModule("static/js/inbound_audio.js");
      await audioCtx.audioWorklet.addModule("static/js/outbound_audio.js");

      const inboundNode = new AudioWorkletNode(audioCtx, "inbound-resampler");
      const outboundNode = new AudioWorkletNode(audioCtx, "outbound-resampler");
      
      // Set up audio routing
      inboundNode.connect(audioCtx.destination);
      inputNode.connect(outboundNode);

      // Set up message handlers
      inboundNode.port.onmessage = (evt) => {
        responseMS += evt.data;
      };

      socket.onmessage = (evt) => {
        const pcm16 = new Int16Array(evt.data);
        inboundNode.port.postMessage(pcm16);
      };

      outboundNode.port.onmessage = (evt) => {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(evt.data);
        }
      };

      // Initialize VAD
      const vadInstance = await vad.MicVAD.new({
        onSpeechStart: () => {
          try {
            const msg = new Uint8Array(5);
            inboundNode.port.postMessage(new Int16Array([SPEECH_STARTED]));
            msg[0] = SPEECH_STARTED;
            new DataView(msg.buffer).setUint32(1, responseMS, true);
            
            if (socket.readyState === WebSocket.OPEN) {
              socket.send(msg);
            }
            console.log("Speech start detected");
            responseMS = 0;
          } catch (error) {
            console.error('Error in speech start handler:', error);
          }
        },
        onSpeechEnd: (audio) => {
          try {
            const msg = new Uint8Array(5);
            msg[0] = SPEECH_ENDED;
            inboundNode.port.postMessage(new Int16Array([SPEECH_ENDED]));
            
            if (socket.readyState === WebSocket.OPEN) {
              socket.send(msg);
            }
          } catch (error) {
            console.error('Error in speech end handler:', error);
          }
        }
      });

      await vadInstance.start();
      
      return {
        cleanup: () => {
          socket.close();
          audioCtx.close();
          vadInstance.stop();
        }
      };

    } catch (error) {
      console.error('Setup failed:', error);
      throw error;
    }
  }

  // Usage
  setupAudioStream()
    .then(({ cleanup }) => {
      // Store cleanup function for later use
      window.cleanupAudio = cleanup;
    })
    .catch(error => {
      console.error('Failed to initialize audio stream:', error);
    });
</script>
</body>
</html>